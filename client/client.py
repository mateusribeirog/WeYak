import tkinter as tk
from tkinter import scrolledtext, messagebox
import socket
import threading
import queue

#GENERATED BY AI JUST TO TEST THE SERVER STRUCTURE

class ChatClient:
    def __init__(self, master):
        self.master = master
        self.master.title("Go Chat Client")
        self.master.geometry("500x550")
        self.master.protocol("WM_DELETE_WINDOW", self.on_closing)

        self.sock = None
        self.is_connected = False
        self.receiver_thread = None
        self.message_queue = queue.Queue()

        self.create_widgets()
        self.check_queue_periodically()

    def create_widgets(self):
        """Creates and lays out the GUI widgets."""
        # --- Connection Frame ---
        self.connection_frame = tk.Frame(self.master, padx=10, pady=10)
        self.connection_frame.pack(fill=tk.X)

        tk.Label(self.connection_frame, text="IP:").grid(row=0, column=0, sticky=tk.W)
        self.ip_entry = tk.Entry(self.connection_frame, width=15)
        self.ip_entry.insert(0, "127.0.0.1")
        self.ip_entry.grid(row=0, column=1, padx=5)

        tk.Label(self.connection_frame, text="Port:").grid(row=0, column=2, sticky=tk.W)
        self.port_entry = tk.Entry(self.connection_frame, width=7)
        self.port_entry.insert(0, "8888")
        self.port_entry.grid(row=0, column=3, padx=5)

        self.connect_button = tk.Button(self.connection_frame, text="Connect", command=self.connect_to_server)
        self.connect_button.grid(row=0, column=4, padx=5)
        
        tk.Label(self.connection_frame, text="Username:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.username_entry = tk.Entry(self.connection_frame)
        self.username_entry.grid(row=1, column=1, columnspan=2, sticky=tk.EW, pady=5)
        
        tk.Label(self.connection_frame, text="Room:").grid(row=1, column=3, sticky=tk.W, pady=5)
        self.room_entry = tk.Entry(self.connection_frame)
        self.room_entry.grid(row=1, column=4, padx=5, sticky=tk.EW)

        # --- Status Label ---
        self.status_var = tk.StringVar(value="Status: Disconnected")
        status_label = tk.Label(self.master, textvariable=self.status_var, relief=tk.SUNKEN, anchor=tk.W)
        status_label.pack(fill=tk.X, ipady=2)

        # --- Chat Display Area ---
        self.chat_area = scrolledtext.ScrolledText(self.master, state='disabled', wrap=tk.WORD, font=("Helvetica", 10))
        self.chat_area.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

        # --- Message Entry Frame ---
        self.message_frame = tk.Frame(self.master, padx=10, pady=5)
        self.message_frame.pack(fill=tk.X)

        self.message_entry = tk.Entry(self.message_frame, state='disabled')
        self.message_entry.bind("<Return>", self.send_message)
        self.message_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)

        self.send_button = tk.Button(self.message_frame, text="Send", command=self.send_message, state='disabled')
        self.send_button.pack(side=tk.RIGHT, padx=5)

    def connect_to_server(self):
        """Handles the connection logic, including the handshake."""
        if self.is_connected:
            return

        ip = self.ip_entry.get()
        port_str = self.port_entry.get()
        username = self.username_entry.get()
        room = self.room_entry.get()

        if not all([ip, port_str, username, room]):
            messagebox.showerror("Error", "All fields must be filled.")
            return

        try:
            port = int(port_str)
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.connect((ip, port))

            # --- Handshake with the Go Server ---
            # The Go server expects data line by line.
            # We must append a newline character ('\n') to everything we send.
            
            # The Go server will send prompts, we just need to send our data.
            # We don't strictly need to read the prompts, but our receive thread will display them.
            
            # Send username
            self.sock.sendall(f"{username}\n".encode('utf-8'))
            
            # Send desired room
            self.sock.sendall(f"{room}\n".encode('utf-8'))
            
            self.is_connected = True
            
            # Start the thread to receive messages from the server
            self.receiver_thread = threading.Thread(target=self.receive_messages, daemon=True)
            self.receiver_thread.start()

            # Update GUI to "connected" state
            self.connect_button.config(state='disabled')
            self.message_entry.config(state='normal')
            self.send_button.config(state='normal')
            self.status_var.set(f"Status: Connected to '{room}' as '{username}'")
            
        except Exception as e:
            messagebox.showerror("Connection Error", f"Failed to connect to server: {e}")
            self.sock = None
            self.is_connected = False

    def receive_messages(self):
        """Runs in a separate thread, continuously receiving messages."""
        buffer = ""
        while self.is_connected:
            try:
                data = self.sock.recv(1024).decode('utf-8')
                if not data:
                    # Server closed the connection
                    break
                
                buffer += data
                while '\n' in buffer:
                    line, buffer = buffer.split('\n', 1)
                    self.message_queue.put(line + '\n')

            except Exception as e:
                print(f"Receiver error: {e}")
                break
        
        # This part runs when the loop breaks (connection lost)
        if self.is_connected:
            self.message_queue.put("--- Connection to server lost. ---\n")
            self.disconnect()

    def check_queue_periodically(self):
        """Checks the message queue and updates the GUI."""
        while not self.message_queue.empty():
            message = self.message_queue.get()
            self.display_message(message)
        self.master.after(100, self.check_queue_periodically)

    def display_message(self, message):
        """Appends a message to the chat area."""
        self.chat_area.config(state='normal')
        self.chat_area.insert(tk.END, message)
        self.chat_area.config(state='disabled')
        self.chat_area.see(tk.END)

    def send_message(self, event=None):
        """Sends a message from the entry box to the server."""
        if not self.is_connected:
            return

        message = self.message_entry.get()
        if message:
            try:
                # Add the crucial newline character for the Go server's scanner
                self.sock.sendall(f"{message}\n".encode('utf-8'))
                self.message_entry.delete(0, tk.END)
            except Exception as e:
                self.display_message("--- Failed to send message. Connection may be lost. ---\n")
                self.disconnect()

    def disconnect(self):
        """Handles disconnection and GUI state reset."""
        self.is_connected = False
        if self.sock:
            self.sock.close()
        self.sock = None
        self.connect_button.config(state='normal')
        self.message_entry.config(state='disabled')
        self.send_button.config(state='disabled')
        self.status_var.set("Status: Disconnected")

    def on_closing(self):
        """Called when the user closes the Tkinter window."""
        self.disconnect()
        self.master.destroy()


if __name__ == "__main__":
    root = tk.Tk()
    client_app = ChatClient(root)
    root.mainloop()